<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Firefox Test Health</title>
    <script src="fetch-utils.js"></script>
    <script>
        // Start fetching data immediately, before Plotly loads
        const xpcshellStatsPromise = fetchData('xpcshell-stats.json');
        const mochitestStatsPromise = fetchData('mochitest-stats.json');
    </script>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <script src="shared.js"></script>
    <link rel="stylesheet" href="shared.css">
    <style>
        .header {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .header h1 {
            margin: 0;
        }

        .header .controls {
            background: transparent;
            padding: 0;
            margin: 0;
            box-shadow: none;
            border-radius: 0;
        }

        .header .controls label {
            font-size: 0.85rem;
            margin-right: 8px;
        }

        .header .controls .btn-group button {
            padding: 6px 12px;
            font-size: 0.85rem;
        }

        .stats-section {
            background: white;
            padding: 25px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .stats-section h2 {
            margin-top: 0;
        }

        .stats-table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed;
        }

        .stats-table th {
            text-align: center;
            padding: 12px 15px;
            border-bottom: 2px solid #e0e0e0;
            font-size: 0.9rem;
            color: #666;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            width: 20%;
        }

        .stats-table th:first-child {
            text-align: left;
        }

        .stats-table td {
            padding: 20px 15px;
            border-bottom: 1px solid #f5f5f5;
            text-align: center;
            vertical-align: top;
        }

        .stats-table td:first-child {
            text-align: left;
        }

        .stats-table tr:last-child td {
            border-bottom: none;
        }

        .stats-table tbody tr:hover {
            background-color: #fafafa;
        }

        .harness-name {
            font-weight: 600;
            color: #333;
            font-size: 1.1rem;
        }

        .stat-cell {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .stat-value {
            font-weight: 600;
            color: #333;
            font-size: 1.8rem;
            line-height: 1;
        }

        .stat-link {
            color: inherit;
            text-decoration: none;
            transition: all 0.2s;
            display: block;
        }

        .stat-link:hover .stat-value {
            color: #0060df;
        }

        .stat-secondary {
            font-size: 0.85rem;
            color: #999;
            white-space: nowrap;
        }

        .chart-container h2 {
            display: inline;
            margin-right: 10px;
        }

        .info-text {
            display: inline;
            font-size: 0.85rem;
            color: #666;
            margin: 0 0 15px 0;
        }

        .chart-header {
            margin-bottom: 15px;
        }

        .chart-container {
            min-height: 0;
        }

        .chart-container > div[id$="Chart"] {
            height: 450px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Firefox Test Health</h1>
        <div class="controls">
            <label>Display:</label>
            <div class="btn-group">
                <button onclick="setDisplayMode('percentage')" class="active" id="btnPercentage">Percentage</button>
                <button onclick="setDisplayMode('count')" id="btnCount">Raw Counts</button>
            </div>
        </div>
    </div>

    <div class="stats-section">
        <h2 id="summary">Summary (Last 7 Days)</h2>
        <table class="stats-table">
            <thead>
                <tr>
                    <th>Harness</th>
                    <th>Flaky Test Failures</th>
                    <th>Flaky Job Failures</th>
                    <th>Skip Rate</th>
                    <th>Invalid Jobs</th>
                </tr>
            </thead>
            <tbody id="statsSummary">
                <tr data-harness="xpcshell">
                    <td class="harness-name">XPCShell</td>
                    <td><div class="stat-cell"><div class="stat-value">—</div><div class="stat-secondary">0,000 / 0,000,000</div></div></td>
                    <td><div class="stat-cell"><div class="stat-value">—</div><div class="stat-secondary">0,000 / 0,000,000</div></div></td>
                    <td><div class="stat-cell"><div class="stat-value">—</div><div class="stat-secondary">0,000 / 0,000,000</div></div></td>
                    <td><div class="stat-cell"><div class="stat-value">—</div><div class="stat-secondary">0,000 / 0,000,000</div></div></td>
                </tr>
                <tr data-harness="mochitest">
                    <td class="harness-name">Mochitest</td>
                    <td><div class="stat-cell"><div class="stat-value">—</div><div class="stat-secondary">0,000 / 0,000,000</div></div></td>
                    <td><div class="stat-cell"><div class="stat-value">—</div><div class="stat-secondary">0,000 / 0,000,000</div></div></td>
                    <td><div class="stat-cell"><div class="stat-value">—</div><div class="stat-secondary">0,000 / 0,000,000</div></div></td>
                    <td><div class="stat-cell"><div class="stat-value">—</div><div class="stat-secondary">0,000 / 0,000,000</div></div></td>
                </tr>
            </tbody>
        </table>
    </div>

    <div class="charts-grid">
        <div class="chart-container" id="testFailureContainer">
            <div class="chart-header">
                <h2 id="test-failures">Flaky Test Failures</h2>
                <p class="info-text">Percentage of test runs that failed</p>
            </div>
            <div id="testFailureChart"></div>
        </div>

        <div class="chart-container" id="jobFailureContainer">
            <div class="chart-header">
                <h2 id="job-failures">Flaky Job Failures</h2>
                <p class="info-text">Percentage of jobs that failed due to test flakiness (excludes invalid jobs from infrastructure or harness issues, and failures due to broken patches that were backed out)</p>
            </div>
            <div id="jobFailureChart"></div>
        </div>

        <div class="chart-container" id="skipRateContainer">
            <div class="chart-header">
                <h2 id="test-skips">Test Skips</h2>
                <p class="info-text">Percentage of tests skipped (excluding platform-irrelevant skips like run-if)</p>
            </div>
            <div id="skipRateChart"></div>
        </div>

        <div class="chart-container" id="xpcshellBreakdownContainer">
            <div class="chart-header">
                <h2 id="failure-breakdown">Job Failure Breakdown</h2>
                <p class="info-text">Breakdown of all failed test jobs by category: intermittent test failures, invalid (infrastructure or harness issues), and backout (known broken patches)</p>
            </div>
            <h3 id="xpcshell-failure-breakdown">XPCShell</h2>
            <div id="xpcshellBreakdownChart"></div>
            <h3 id="mochitest-failure-breakdown">Mochitest</h2>
            <div id="mochitestBreakdownChart"></div>
        </div>
    </div>

    <div id="errorMessage" class="error" style="display: none;"></div>

    <script>
        let xpcshellStats = null;
        let mochitestStats = null;
        let currentDisplayMode = 'percentage';

        async function loadData() {
            try {
                // Await the fetches started before Plotly loaded
                const [xpcResponse, mochResponse] = await Promise.all([
                    xpcshellStatsPromise, mochitestStatsPromise
                ]);

                if (xpcResponse.ok) {
                    xpcshellStats = await xpcResponse.json();
                    console.log('Loaded XPCShell stats:', xpcshellStats.dates.length, 'days');
                }

                if (mochResponse.ok) {
                    mochitestStats = await mochResponse.json();
                    console.log('Loaded Mochitest stats:', mochitestStats.dates.length, 'days');
                }

                if (!xpcshellStats && !mochitestStats) {
                    throw new Error('No stats data available');
                }

                updateDisplay();
            } catch (error) {
                console.error('Failed to load stats:', error);
                document.getElementById('errorMessage').textContent =
                    'Error: Could not load statistics. Generate stats by running: node fetch-test-data.js --harness xpcshell --days 30 && node fetch-test-data.js --harness mochitest --days 30';
                document.getElementById('errorMessage').style.display = 'block';
            }
        }

        function setDisplayMode(mode) {
            currentDisplayMode = mode;
            document.getElementById('btnPercentage').classList.remove('active');
            document.getElementById('btnCount').classList.remove('active');
            document.getElementById(`btn${mode.charAt(0).toUpperCase() + mode.slice(1)}`).classList.add('active');
            updateDisplay();
        }

        function getRecentStats(stats, days = 7) {
            if (!stats) return null;

            const count = Math.min(days, stats.dates.length);
            return {
                dates: stats.dates.slice(-count),
                totalTestRuns: stats.totalTestRuns.slice(-count),
                failedTestRuns: stats.failedTestRuns.slice(-count),
                skippedTestRuns: stats.skippedTestRuns.slice(-count),
                processedJobCount: stats.processedJobCount.slice(-count),
                failedJobs: stats.failedJobs.slice(-count),
                invalidJobs: stats.invalidJobs.slice(-count),
                ignoredJobs: stats.ignoredJobs ? stats.ignoredJobs.slice(-count) : new Array(count).fill(0)
            };
        }

        function sumArray(arr) {
            let sum = 0;
            for (let i = 0; i < arr.length; i++) {
                if (arr[i] !== null) {
                    sum += arr[i];
                }
            }
            return sum;
        }

        function updateStatsSummary() {
            const harnesses = [
                { name: 'XPCShell', kind: 'xpcshell', stats: xpcshellStats },
                { name: 'Mochitest', kind: 'mochitest', stats: mochitestStats }
            ];

            for (const harness of harnesses) {
                const row = document.querySelector(`tr[data-harness="${harness.kind}"]`);
                if (!row) continue;

                const data = getRecentStats(harness.stats, 7);
                if (!data) continue;

                const totalTests = sumArray(data.totalTestRuns);
                const totalFailed = sumArray(data.failedTestRuns);
                const totalSkipped = sumArray(data.skippedTestRuns);
                const totalJobs = sumArray(data.processedJobCount);
                const failedJobs = sumArray(data.failedJobs);
                const invalidJobs = sumArray(data.invalidJobs);
                const testFailedJobs = failedJobs - invalidJobs; // Only test-related failures

                const testFailRate = totalTests > 0 ? ((totalFailed / totalTests) * 100).toFixed(2) : '0.00';
                const jobFailRate = totalJobs > 0 ? ((testFailedJobs / totalJobs) * 100).toFixed(2) : '0.00';
                const skipRate = totalTests > 0 ? ((totalSkipped / totalTests) * 100).toFixed(2) : '0.00';
                const invalidRate = totalJobs > 0 ? ((invalidJobs / totalJobs) * 100).toFixed(2) : '0.00';

                row.innerHTML = `
                    <td class="harness-name">${harness.name}</td>
                    <td>
                        <a href="issues.html?kind=${harness.kind}#date=21days" class="stat-link" title="Percentage of test runs that failed">
                            <div class="stat-cell">
                                <div class="stat-value">${testFailRate}%</div>
                                <div class="stat-secondary">${totalFailed.toLocaleString()} / ${totalTests.toLocaleString()}</div>
                            </div>
                        </a>
                    </td>
                    <td>
                        <a href="green.html#${harness.kind}" class="stat-link" title="Percentage of jobs that failed due to test flakiness (excludes invalid jobs from infrastructure issues, and failures due to broken patches that were backed out)">
                            <div class="stat-cell">
                                <div class="stat-value">${jobFailRate}%</div>
                                <div class="stat-secondary">${testFailedJobs.toLocaleString()} / ${totalJobs.toLocaleString()}</div>
                            </div>
                        </a>
                    </td>
                    <td title="Percentage of test runs that were skipped (excludes platform-irrelevant skips like run-if)">
                        <div class="stat-cell">
                            <div class="stat-value">${skipRate}%</div>
                            <div class="stat-secondary">${totalSkipped.toLocaleString()} / ${totalTests.toLocaleString()}</div>
                        </div>
                    </td>
                    <td title="Percentage of jobs that failed to produce valid results due to infrastructure issues (harness failures, timeouts, etc.)">
                        <div class="stat-cell">
                            <div class="stat-value">${invalidRate}%</div>
                            <div class="stat-secondary">${invalidJobs.toLocaleString()} / ${totalJobs.toLocaleString()}</div>
                        </div>
                    </td>
                `;
            }
        }

        function createPercentageTrace(dates, numerator, denominator, name, color) {
            const yValues = [];
            const validDates = [];
            const customData = [];

            for (let i = 0; i < dates.length; i++) {
                if (numerator[i] !== null && denominator[i] !== null && denominator[i] > 0) {
                    const percentage = (numerator[i] / denominator[i]) * 100;
                    yValues.push(currentDisplayMode === 'percentage' ? percentage : numerator[i]);
                    validDates.push(dates[i]);
                    customData.push({
                        numerator: numerator[i].toLocaleString(),
                        denominator: denominator[i].toLocaleString(),
                        percentage: percentage.toFixed(2)
                    });
                }
            }

            return {
                x: validDates,
                y: yValues,
                type: 'scatter',
                mode: 'lines+markers',
                name: name,
                line: { color: color, width: 2 },
                marker: { size: 6 },
                customdata: customData,
                hovertemplate: '<b>%{fullData.name}</b><br>' +
                               'Date: %{x}<br>' +
                               'Percentage: %{customdata.percentage}%<br>' +
                               'Count: %{customdata.numerator} / %{customdata.denominator}<br>' +
                               '<extra></extra>'
            };
        }

        function chartLayout(yLabel) {
            return {
                xaxis: { title: 'Date', type: 'date' },
                yaxis: { title: yLabel, rangemode: 'tozero' },
                hovermode: 'closest',
                showlegend: true,
                margin: { l: 60, r: 40, t: 20, b: 60 },
                hoverlabel: {
                    bgcolor: '#2a2a2a',
                    bordercolor: '#2a2a2a',
                    font: {
                        size: 15,
                        color: 'white',
                        family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif'
                    }
                }
            };
        }

        function createTestFailureChart() {
            const traces = [];
            if (xpcshellStats) {
                traces.push(createPercentageTrace(
                    xpcshellStats.dates, xpcshellStats.failedTestRuns,
                    xpcshellStats.totalTestRuns, 'XPCShell', '#0060df'));
            }
            if (mochitestStats) {
                traces.push(createPercentageTrace(
                    mochitestStats.dates, mochitestStats.failedTestRuns,
                    mochitestStats.totalTestRuns, 'Mochitest', '#ff6b6b'));
            }
            Plotly.newPlot('testFailureChart', traces,
                chartLayout(currentDisplayMode === 'percentage' ? 'Failure Percentage (%)' : 'Failed Test Runs'),
                { responsive: true });
        }

        function createJobFailureChart() {
            const traces = [];
            for (const [stats, name, color] of [[xpcshellStats, 'XPCShell', '#0060df'], [mochitestStats, 'Mochitest', '#ff6b6b']]) {
                if (!stats) continue;
                const testFailedJobs = stats.failedJobs.map((failed, i) =>
                    (failed !== null && stats.invalidJobs[i] !== null) ? failed - stats.invalidJobs[i] : failed);
                traces.push(createPercentageTrace(stats.dates, testFailedJobs, stats.processedJobCount, name, color));
            }
            Plotly.newPlot('jobFailureChart', traces,
                chartLayout(currentDisplayMode === 'percentage' ? 'Failure Percentage (%)' : 'Failed Jobs'),
                { responsive: true });
        }

        function createSkipRateChart() {
            const traces = [];
            if (xpcshellStats) {
                traces.push(createPercentageTrace(
                    xpcshellStats.dates, xpcshellStats.skippedTestRuns,
                    xpcshellStats.totalTestRuns, 'XPCShell', '#0060df'));
            }
            if (mochitestStats) {
                traces.push(createPercentageTrace(
                    mochitestStats.dates, mochitestStats.skippedTestRuns,
                    mochitestStats.totalTestRuns, 'Mochitest', '#ff6b6b'));
            }
            Plotly.newPlot('skipRateChart', traces,
                chartLayout(currentDisplayMode === 'percentage' ? 'Skip Percentage (%)' : 'Skipped Test Runs'),
                { responsive: true });
        }

        function createBreakdownChart(chartId, stats) {
            if (!stats) return;
            const intermittent = stats.failedJobs.map((failed, i) =>
                (failed !== null && stats.invalidJobs[i] !== null) ? failed - stats.invalidJobs[i] : failed);

            function makeStackTrace(name, color, values) {
                const customData = [], yValues = [];
                for (let i = 0; i < stats.dates.length; i++) {
                    const total = stats.processedJobCount[i] + (stats.invalidJobs[i] || 0) + (stats.ignoredJobs[i] || 0);
                    const val = values[i];
                    const percentage = total > 0 && val !== null ? (val / total * 100) : null;
                    yValues.push(currentDisplayMode === 'percentage' ? percentage : val);
                    customData.push({
                        count: val !== null ? val.toLocaleString() : '0',
                        total: total.toLocaleString(),
                        percentage: percentage !== null ? percentage.toFixed(2) : '0.00'
                    });
                }
                return {
                    x: stats.dates, y: yValues, name, type: 'scatter', mode: 'lines',
                    stackgroup: 'one', line: { color, width: 0 }, fillcolor: color,
                    customdata: customData,
                    hovertemplate: `<b>${name}</b><br>Date: %{x}<br>Percentage: %{customdata.percentage}%<br>Count: %{customdata.count} / %{customdata.total}<br><extra></extra>`
                };
            }

            Plotly.newPlot(chartId, [
                makeStackTrace('Intermittent', '#ff9500', intermittent),
                makeStackTrace('Invalid', '#888', stats.invalidJobs),
                makeStackTrace('Backout', '#0060df', stats.ignoredJobs)
            ], chartLayout(currentDisplayMode === 'percentage' ? 'Percentage of Total Jobs (%)' : 'Job Count'),
               { responsive: true });
        }

        function createBreakdownCharts() {
            createBreakdownChart('xpcshellBreakdownChart', xpcshellStats);
            createBreakdownChart('mochitestBreakdownChart', mochitestStats);
        }

        // Lazy chart creation: track which containers are visible,
        // only create charts when their container scrolls into view.
        const chartCreators = new Map([
            ['testFailureContainer', createTestFailureChart],
            ['jobFailureContainer', createJobFailureChart],
            ['skipRateContainer', createSkipRateChart],
            ['xpcshellBreakdownContainer', createBreakdownCharts],
        ]);
        const visibleContainers = new Set();
        let dataReady = false;

        const chartObserver = new IntersectionObserver((entries) => {
            for (const entry of entries) {
                if (entry.isIntersecting) {
                    visibleContainers.add(entry.target.id);
                    if (dataReady) {
                        chartCreators.get(entry.target.id)();
                    }
                } else {
                    visibleContainers.delete(entry.target.id);
                }
            }
        }, { rootMargin: '200px' });

        for (const [id] of chartCreators) {
            chartObserver.observe(document.getElementById(id));
        }

        function updateDisplay() {
            if (!xpcshellStats && !mochitestStats) return;
            dataReady = true;

            requestAnimationFrame(() => {
                updateStatsSummary();
                setTimeout(() => {
                    for (const id of visibleContainers) {
                        chartCreators.get(id)();
                    }
                }, 0);
            });
        }

        // Add click handlers to h2 elements for anchor functionality
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelectorAll('h2[id]').forEach(function(header) {
                header.addEventListener('click', function() {
                    window.location.hash = '#' + this.id;
                });
            });
        });

        setupWindowResize();
        loadData();
    </script>
</body>
</html>
